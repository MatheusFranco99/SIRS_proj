import sys
import socket, ssl
import threading
import datetime
import pickle

from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5 as PKCS_SIGN

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import os


# Global variables 
sns_DB = [] # sns codes
proxy_IP = '192.168.0.4'
sns_IP = '192.168.0.4'

my_IP = '192.168.0.1'
my_port = 60000

users_port = 60000

users_reg = []
users_logged = []
users_password = {} # ip : password
users_salt = {} # ip : salt
users_name = []

verbose_mode = False
quit_program = False

SERVER_PICKLE = 'server_pickle'

with open("server.key", "rb") as k:
    key_priv = RSA.importKey(k.read())

with open("public_sns.key", "rb") as k:
    sns_public_key = RSA.importKey(k.read())

# function that print information when the program runs in verbose mode
def print_console(*argv):
    if verbose_mode:
        uniq = ""
        for arg in argv:
            uniq += str(arg) + " "
        uniq = uniq[:-1]
        print(uniq)

# decrypt data with the private key (server private key)
def decrypt_data(data):
    decipher = PKCS1_v1_5.new(key_priv)
    return decipher.decrypt(data, None)

# checks if the signature is valid for the message msg
def validate_signature(msg, signature):
    digest = SHA256.new()
    digest.update(msg)

    verifier = PKCS_SIGN.new(sns_public_key)
    verified = verifier.verify(digest, signature)

    if verified:
        #check freshness
        timestamp1 = datetime.datetime.now().timestamp()
        timestamp2 = float(msg.split(b":")[0])
        if timestamp1 - timestamp2 < 5:     #5 seconds
            return True
    
    return False

# RECEIVE:
# from SNS when user is positive for covid19
# COD:<sns_code>:\n"
def received_cod(sns_code):
    global sns_DB
    # Adds the sns_code generated by the sns to a list with all sns codes received
    sns_DB.append(sns_code)
    
# RECEIVE:
# from a positive user
# POS:<sns_code>:(<encrypt_token>:)*\n

# SEND:
# from server to all users the infected tokens
# CON:(<token>:)*\n
def received_pos(sns_code, tokens):
    global sns_DB

    if sns_code not in sns_DB:
        print("Error: Invalid sns_code")

    msg = 'CON:' + ":".join(tokens) + ":\n"

    for ip in users_reg:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        client = ssl.wrap_socket(client, keyfile='server.key', certfile='server.crt')

        print_console("--Send message--")
        print_console("To (host,port): " + str(ip) + "," + str(users_port) + ". Sent: " + msg)

        try:
            client.connect((ip, users_port))
        except socket.error:
            print("User Unreachable")
            continue
        client.send(msg.encode("utf-8"))
        client.close()
    


# RECEIVE:
# from a user who wants to register
# REG:<name>:<password>:\n

# SEND:
# list of logged in ips
# REA:\n or REF:<error>:\n
def received_reg(ip_user,passw,name):
    global users_logged, users_reg, users_password, users_salt, users_name

    msg = ""
    if name in users_name:
        msg = 'REF:Username already exist:\n'
    elif ip_user in users_reg:
        msg = 'REF:User already registered:\n'
    elif len(passw) < 10:
        msg = 'REF:Password must have at least 10 characters:\n'
    else:
        # check password strongness
        contains_digit = False
        contains_capital = False
        contains_small = False
        invalid_char = False
        for ch in passw:
            if('a' <= ch and ch <= 'z'):
                contains_small = True
            elif('A' <= ch and ch <= 'Z'):
                contains_capital = True
            elif('0' <= ch and ch <= '9'):
                contains_digit = True
            else:
                invalid_char = True
        
        if(invalid_char or (not contains_capital) or (not contains_digit) or (not contains_small)):
            msg = 'REF:Password must have at least one capital letter, one small letter and one digit:\n'
        else:
            users_reg.append(ip_user)

            salt = os.urandom(16) # salt 128 bits
            hash_object = SHA256.new()
            hex_dig = hash_object.update(passw.encode("utf-8") + salt)
            users_salt[ip_user] = salt
            users_password[ip_user] = hex_dig
            users_name.append(name)
        
            msg = 'REA:\n'

    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    client = ssl.wrap_socket(client, keyfile='server.key', certfile='server.crt')

    print_console("--Send message--")
    print_console("To (host,port): " + str(ip_user) + "," + str(users_port) + ". Sent: " + msg)

    try:
        client.connect((ip_user, users_port))
    except socket.error:
        print("User Unreachable")
        return
    client.send(msg.encode("utf-8"))
    client.close()
    

# RECEIVE:
# from a user who wants to login
# LOG:<password>:\n

# SEND:
# list of ips logged in
# LOA:(<ips>:)*\n or LOF:<error>:\n
def received_log(ip_user,passw):
    global users_logged, users_reg, users_password, users_salt

    msg = ""

    if(ip_user not in users_reg):
        msg = 'LOF:User not registered:\n'
    else:
        hash_object = SHA256.new()
        hex_dig = hash_object.update(passw.encode("utf-8") + users_salt[ip_user])

        if(hex_dig != users_password[ip_user]):
            msg = 'LOF:Wrong password:\n'
        else:
            msg = 'LOA:'
            for ip in users_logged:
                msg = msg + ip + ":"
            msg += '\n'
            if ip_user not in users_logged:
                users_logged.append(ip_user)

    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    client = ssl.wrap_socket(client, keyfile='server.key', certfile='server.crt')

    print_console("--Send message--")
    print_console("To (host,port): " + str(ip_user) + "," + str(users_port) + ". Sent: " + msg)

    try:
        client.connect((ip_user, users_port))
    except socket.error:
        print("User Unreachable")
        return
    client.send(msg.encode("utf-8"))
    client.close()
    

# RECEIVE:
# from a user who logged out
# LGT:\n
def received_lgt(ip_user):
    global users_logged, users_reg

    users_logged.remove(ip_user)
    

# check what type of message was received and handle it in the corresponding way
def handle_message(msg, client_addr, ciphertext = False):

    # if it is encrypted text check if it comes from sns or proxy
    if ciphertext:
        cod_msg = b':CIPHER_COD_MSG:'
        if cod_msg in msg:
            # sns msg
            ciphered_args = msg.split(cod_msg)

            secret_enc = ciphered_args[0]
            cipher_msg = ciphered_args[1].split(b':SIGNATURE:')[0]
            signature = ciphered_args[1].split(b':SIGNATURE:')[1]

            secret = decrypt_data(secret_enc)
            secret_key = secret.split(b':INITIALVECTOR:')[0]
            iv = secret.split(b':INITIALVECTOR:')[1]

            aes_dec = AES.new(secret_key, AES.MODE_CBC, iv)
            message = unpad(aes_dec.decrypt(cipher_msg), AES.block_size)

            if not validate_signature(message, signature):
                return
            
            msg = (message.split(b":", 1)[1]).decode("utf-8")

        else:
            # proxy msg
            msg = decrypt_data(msg).decode()

    print_console("--Received message--")
    print_console("From (host,port): " + str(client_addr[0]) + "," + str(client_addr[1]) + ". Sent: " + msg)

    # parse message
    msg_args = msg.split(':')

    if(msg_args[-1] != '\n'): # wrong formatting - ignore
        return

    if(msg_args[0] == 'COD'): # COD:<sns_cod>:\n
        sns_code = ""
        try:
            assert(len(msg_args) == 3)
            sns_code = msg_args[1]
        except:
            return
        received_cod(sns_code)

    elif(msg_args[0] == 'POS'): # POS:<sns_cod>:<tokens>*:\n
        sns_code = ""
        tokens = []
        try:
            assert(len(msg_args) >= 4)
            sns_code = msg_args[1]
            msg_args.pop(0) # delete POS
            msg_args.pop(0) # delete sns_code
            msg_args.pop(-1) # delete \n
            # only the tokens left
            tokens = msg_args
        except:
            return
        received_pos(sns_code, tokens)
    
    elif(msg_args[0] == 'REG'): # REG:<name>:<password>*:\n
        user_ip = ''
        passw = ""
        name = ""
        try:
            assert(len(msg_args) == 4)
            user_ip = client_addr[0]
            name = msg_args[1]
            passw = msg_args[2]
        except:
            return
        received_reg(user_ip,passw,name)
    
    elif(msg_args[0] == 'LOG'): # LOG:<password>:\n
        user_ip = ''
        passw = ""
        try:
            assert(len(msg_args) == 3)
            user_ip = client_addr[0]
            passw = msg_args[1]
        except:
            return
        received_log(user_ip,passw)

    elif(msg_args[0] == 'LGT'): # LGT:\n
        user_ip = ''
        try:
            assert(len(msg_args) == 2)
            user_ip = client_addr[0]
        except:
            return
        received_lgt(user_ip)

    elif(msg_args[0] == 'NEG'):
        pass

    else:
        # message not in the server's protocol
        print("Message received unknown: " + msg)


# wait for connections on the port 60000
def listen(server_port):
    print("Server listening...")

    HOST = my_IP

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    

    server = ssl.wrap_socket(
        server, server_side=True, keyfile="server.key", certfile="server.crt"
    ) 
    
    server.bind((HOST, server_port))
    server.listen(5)

    threads_lst = []
    
    while not quit_program:
        server.settimeout(2)
        clientConnection = None
        clientAddress = None
        try:
            (clientConnection, clientAddress) = server.accept()
        except:
            continue

        if clientAddress[0] == proxy_IP or clientAddress[0] == sns_IP:  # proxy and sns sends ciphertext, can't decode
            msg = b''
            while True:
                data = clientConnection.recv(1024)
                if not data:
                    break
                msg = msg + data
            t1 = threading.Thread(target = handle_message, args = (msg, clientAddress, True,))
        else:
            msg = ""
            while True:
                data = clientConnection.recv(1024)
                data = data.decode('utf-8')
                if not data:
                    break
                msg = msg + data
            t1 = threading.Thread(target = handle_message, args = (msg, clientAddress, False,))
        
        clientConnection.close()    
        t1.start()

        # take completed threads out of the list
        idx_t = 0
        while idx_t < len(threads_lst):
            if(threads_lst[idx_t].is_alive()):
                idx_t += 1
            else:
                threads_lst[idx_t].join()
                threads_lst.pop(idx_t)

        # add task just started to the list
        threads_lst += [t1]

        # make backup of the pickle
        picklefile = open(SERVER_PICKLE,'wb')

        # STORES sns_DB/users_reg/users_logged/users_password/users_salt/users_name
        pickle.dump(sns_DB,picklefile)
        pickle.dump(users_reg,picklefile)
        pickle.dump(users_logged,picklefile)
        pickle.dump(users_password,picklefile)
        pickle.dump(users_salt,picklefile)
        pickle.dump(users_name,picklefile)
        picklefile.close()

    
    for thr in threads_lst:
        thr.join()

def usage():
    sys.stderr.write('Usage: python3 server.py\nor\nUsage: python3 server.py server_pickle\nFlag: [-v]\n')
    sys.exit(1)

if __name__ == "__main__":

    for arg in sys.argv:
        if arg == "-v":
            verbose_mode = True
            sys.argv.remove(arg)
            break

    if len(sys.argv) != 1 and len(sys.argv) != 2:
        usage()

    print("Server turned on!")

    
    if (len(sys.argv) == 2):
        #get info
        filename = sys.argv[1]
        picklefile = open(filename,'rb')

        # LOAD sns_DB/users_reg/users_logged/users_password/users_salt/users_name
        sns_DB = pickle.load(picklefile)
        users_reg = pickle.load(picklefile)
        users_logged = pickle.load(picklefile)
        users_password = pickle.load(picklefile)
        users_salt = pickle.load(picklefile)
        users_name = pickle.load(picklefile)
        picklefile.close()

    SERVER_PORT = my_port
    
    # cria thread listen
    t1 = threading.Thread(target = listen, args = (SERVER_PORT,) )
    t1.start()

    input("Enter anything to quit:")
    quit_program = True

    t1.join()

    picklefile = open(SERVER_PICKLE,'wb')

    # STORES sns_DB/users_reg/users_logged/users_password/users_salt/users_name
    pickle.dump(sns_DB,picklefile)
    pickle.dump(users_reg,picklefile)
    pickle.dump(users_logged,picklefile)
    pickle.dump(users_password,picklefile)
    pickle.dump(users_salt,picklefile)
    pickle.dump(users_name,picklefile)
    picklefile.close()