import sys
import socket, ssl
import threading
import datetime


# Global variables 
sns_DB = [] # sns codes
users = ['192.168.0.2', '192.168.0.3']  # address of all active users - com o broadcast acho que isto nao vai ser preciso

# RECEBE:
# do SNS quando user esta positivo pra covid19
# COD:<sns_code>:\n"
def received_cod(sns_code):
    print("Handling sns code")
    global sns_DB
    # Adds the sns_code generated by the sns to a list with all sns codes received
    sns_DB.append(sns_code)
    print("----")
    
# RECEBE:
# De um user positivo
# POS:<sns_code>:(<encrypt_token>:)*\n

# ENVIA:
# do server quando alguem tem covid
# CON:(<token>:)*\n
def received_pos(sns_code, tokens):
    print("Handling positive user")
    global sns_DB, users

    if sns_code not in sns_DB:
        print("Error: Invalid sns_code")

    msg = 'CON:' + ":".join(tokens) + ":\n"
    print("msg: " + msg)

    for ip in users:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        client = ssl.wrap_socket(client, keyfile='server.key', certfile='server.crt')

        client.connect((ip, 60000))
        client.send(msg.encode("utf-8"))
        client.close()
    
    print("----")

    # Falta udp broadcast para enviar os tokens aos users (send aqui receive nos clients)
    # acho que Ã© mais facil falar com voces para poder mexer no client e implementar isto que 
    # faz-se rapido


    
def handle_message(msg):

    # parse message
    msg_args = msg.split(':')

    if(msg_args[-1] != '\n'): # wrong formatting - ignore
        return

    # check what type of message was received and handle it in the corresponding way
    if(msg_args[0] == 'COD'):
        sns_code = ""
        try:
            assert(len(msg_args) == 3)
            sns_code = msg_args[1]
        except:
            return
        received_cod(sns_code)

    elif(msg_args[0] == 'POS'):
        sns_code = ""
        tokens = []
        try:
            assert(len(msg_args) <= 4)
            sns_code = msg_args[1]
            msg_args.pop(0) # delete POS
            msg_args.pop(0) # delete sns_code
            msg_args.pop(-1) # delete \n
            # only the tokens left
            tokens = msg_args
        except:
            return
        received_pos(sns_code, tokens)

    else:
        # message not in the server's protocol
        print("Message received unknown: " + msg)



def listen(server_port):
    print("Server listening...")

    HOST = "192.168.0.1"

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    

    server = ssl.wrap_socket(
        server, server_side=True, keyfile="server.key", certfile="server.crt"
    ) 
    
    server.bind((HOST, server_port))
    server.listen(5)

    threads_lst = []
    
    while True:
        (clientConnection, clientAddress) = server.accept()
        msg = ""
        while True:
            data = clientConnection.recv(1024).decode('utf-8')
            if not data:
                break
            msg = msg + data
        print("Received: " + msg)
        clientConnection.close()

        t1 = threading.Thread(target = handle_message, args = (msg,))    
        t1.start()

        idx_t = 0
        while idx_t < len(threads_lst):
            if(threads_lst[idx_t].is_alive()):
                idx_t += 1
            else:
                threads_lst[idx_t].join()
                threads_lst.pop(idx_t)

        threads_lst += [t1]



if __name__ == "__main__":
    print("Server turned on!")

    SERVER_PORT =  60000
    
    # cria thread listen
    t1 = threading.Thread(target = listen, args = (SERVER_PORT,) )
    t1.start()

    t1.join()